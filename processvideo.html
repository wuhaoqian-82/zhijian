<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‘„åƒå¤´å½•åˆ¶è§†é¢‘åˆ†æ</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .video-container {
      text-align: center;
      margin: 20px 0;
    }
    video {
      max-width: 100%;
      border: 2px solid #ddd;
      border-radius: 8px;
    }
    .controls {
      margin: 20px 0;
      text-align: center;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .start-btn { background-color: #4CAF50; color: white; }
    .stop-btn { background-color: #f44336; color: white; }
    .analyze-btn { background-color: #2196F3; color: white; }
    .download-btn { background-color: #FF9800; color: white; }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .status {
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }
    .status.recording { background-color: #ffebee; color: #c62828; }
    .status.ready { background-color: #e8f5e8; color: #2e7d32; }
    .status.processing { background-color: #fff3e0; color: #ef6c00; }
    #result {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #f9f9f9;
    }
    .emotion-item {
      margin: 5px 0;
      padding: 8px;
      background-color: white;
      border-radius: 3px;
      border-left: 4px solid #2196F3;
    }
    .recording-time {
      font-size: 18px;
      font-weight: bold;
      color: #f44336;
    }
  </style>
</head>
<body>
  <h2>æ‘„åƒå¤´å½•åˆ¶è§†é¢‘è¡¨æƒ…ä¸è¯­éŸ³åˆ†æ</h2>
  
  <div class="video-container">
    <video id="preview" width="640" height="480" autoplay muted playsinline></video>
  </div>
  
  <div class="controls">
    <button id="startBtn" class="start-btn">å¼€å§‹å½•åˆ¶</button>
    <button id="stopBtn" class="stop-btn" disabled>åœæ­¢å½•åˆ¶</button>
    <button id="analyzeBtn" class="analyze-btn" disabled>åˆ†æè§†é¢‘</button>
    <button id="downloadBtn" class="download-btn" disabled>ä¸‹è½½å½•åˆ¶è§†é¢‘</button>
  </div>
  
  <div id="status" class="status">ç‚¹å‡»"å¼€å§‹å½•åˆ¶"å¼€å§‹å½•åˆ¶è§†é¢‘</div>
  <div id="recordingTime" class="recording-time" style="display: none;"></div>
  
  <div id="result"></div>

  <script>
    class VideoRecorder {
      constructor() {
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.stream = null;
        this.recordingStartTime = null;
        this.recordingTimer = null;
        
        this.preview = document.getElementById('preview');
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.analyzeBtn = document.getElementById('analyzeBtn');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.status = document.getElementById('status');
        this.recordingTime = document.getElementById('recordingTime');
        this.result = document.getElementById('result');
        
        this.init();
      }
      
      async init() {
        try {
          // è¯·æ±‚æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™
          this.stream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              frameRate: { ideal: 30 }
            },
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });
          
          this.preview.srcObject = this.stream;
          this.setupEventListeners();
          this.updateStatus('æ‘„åƒå¤´å·²å‡†å¤‡å°±ç»ª', 'ready');
          
        } catch (error) {
          console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
          this.updateStatus('æ‘„åƒå¤´è®¿é—®å¤±è´¥: ' + error.message, 'error');
        }
      }
      
      setupEventListeners() {
        this.startBtn.addEventListener('click', () => this.startRecording());
        this.stopBtn.addEventListener('click', () => this.stopRecording());
        this.analyzeBtn.addEventListener('click', () => this.analyzeVideo());
        this.downloadBtn.addEventListener('click', () => this.downloadVideo());
      }
      
      async startRecording() {
        try {
          this.recordedChunks = [];
          
          // é…ç½®å½•åˆ¶é€‰é¡¹
          const options = {
            mimeType: 'video/webm;codecs=vp9,opus',
            videoBitsPerSecond: 1000000, // 1Mbps
            audioBitsPerSecond: 128000   // 128kbps
          };
          
          // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒçš„æ ¼å¼
          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options.mimeType = 'video/webm';
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
              options.mimeType = 'video/mp4';
            }
          }
          
          this.mediaRecorder = new MediaRecorder(this.stream, options);
          
          this.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              this.recordedChunks.push(event.data);
            }
          };
          
          this.mediaRecorder.onstop = () => {
            this.onRecordingComplete();
          };
          
          this.mediaRecorder.start(1000); // æ¯ç§’æ”¶é›†ä¸€æ¬¡æ•°æ®
          
          this.recordingStartTime = Date.now();
          this.startRecordingTimer();
          
          this.startBtn.disabled = true;
          this.stopBtn.disabled = false;
          this.analyzeBtn.disabled = true;
          this.downloadBtn.disabled = true;
          
          this.updateStatus('æ­£åœ¨å½•åˆ¶...', 'recording');
          
        } catch (error) {
          console.error('å¼€å§‹å½•åˆ¶å¤±è´¥:', error);
          this.updateStatus('å½•åˆ¶å¤±è´¥: ' + error.message, 'error');
        }
      }
      
      stopRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
          this.mediaRecorder.stop();
        }
        
        this.stopRecordingTimer();
        
        this.startBtn.disabled = false;
        this.stopBtn.disabled = true;
        
        this.updateStatus('å½•åˆ¶å®Œæˆï¼Œå¯ä»¥è¿›è¡Œåˆ†æ', 'ready');
      }
      
      startRecordingTimer() {
        this.recordingTime.style.display = 'block';
        this.recordingTimer = setInterval(() => {
          const elapsed = Date.now() - this.recordingStartTime;
          const seconds = Math.floor(elapsed / 1000);
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;
          this.recordingTime.textContent = 
            `å½•åˆ¶æ—¶é—´: ${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
      }
      
      stopRecordingTimer() {
        if (this.recordingTimer) {
          clearInterval(this.recordingTimer);
          this.recordingTimer = null;
        }
        this.recordingTime.style.display = 'none';
      }
      
      onRecordingComplete() {
        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
        this.recordedBlob = blob;
        
        this.analyzeBtn.disabled = false;
        this.downloadBtn.disabled = false;
        
        // æ˜¾ç¤ºå½•åˆ¶çš„è§†é¢‘å¤§å°
        const sizeInMB = (blob.size / (1024 * 1024)).toFixed(2);
        this.updateStatus(`å½•åˆ¶å®Œæˆ (${sizeInMB} MB)ï¼Œå¯ä»¥è¿›è¡Œåˆ†ææˆ–ä¸‹è½½`, 'ready');
      }
      
      async analyzeVideo() {
        if (!this.recordedBlob) {
          alert('æ²¡æœ‰å½•åˆ¶çš„è§†é¢‘');
          return;
        }
        
        this.updateStatus('æ­£åœ¨åˆ†æè§†é¢‘...', 'processing');
        this.analyzeBtn.disabled = true;
        this.result.innerHTML = '<div style="text-align: center;">ğŸ”„ æ­£åœ¨å¤„ç†è§†é¢‘ï¼Œè¯·ç¨å€™...</div>';
        
        try {
          // å°†Blobè½¬æ¢ä¸ºBase64
          const base64Data = await this.blobToBase64(this.recordedBlob);
          
          const response = await fetch('http://localhost:3100/api/video/analyze-base64', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              videoData: base64Data,
              filename: `recorded_${Date.now()}.webm`
            })
          });
          
          if (!response.ok) {
            throw new Error(`æœåŠ¡å™¨é”™è¯¯: ${response.status}`);
          }
          
          const data = await response.json();
          
          if (data.success) {
            this.displayResults(data);
            this.updateStatus('åˆ†æå®Œæˆ', 'ready');
          } else {
            throw new Error(data.error || 'åˆ†æå¤±è´¥');
          }
          
        } catch (error) {
          console.error('åˆ†æå¤±è´¥:', error);
          this.result.innerHTML = `<div style="color: red;">âŒ åˆ†æå¤±è´¥: ${this.escapeHtml(error.message)}</div>`;
          this.updateStatus('åˆ†æå¤±è´¥', 'error');
        } finally {
          this.analyzeBtn.disabled = false;
        }
      }
      
      blobToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }
      
      displayResults(data) {
        const { emotionTimeline, asrText, processedFrames } = data;
        
        const emotionHtml = emotionTimeline.map(item => 
          `<div class="emotion-item">
            <strong>å¸§ ${this.escapeHtml(item.frame)}:</strong> 
            ${this.formatEmotion(item.emotion)}
          </div>`
        ).join('');
        
        this.result.innerHTML = `
          <h3>ğŸ“Š åˆ†æç»“æœ</h3>
          <div style="margin-bottom: 20px;">
            <h4>ğŸ¤ è¯­éŸ³è¯†åˆ«ç»“æœ:</h4>
            <div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
              <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">${this.escapeHtml(asrText || 'æœªè¯†åˆ«åˆ°è¯­éŸ³å†…å®¹')}</pre>
            </div>
          </div>
          
          <div>
            <h4>ğŸ˜Š è¡¨æƒ…å˜åŒ–åˆ†æ (å…±å¤„ç† ${processedFrames} å¸§):</h4>
            <div style="max-height: 400px; overflow-y: auto;">
              ${emotionHtml || '<div>æœªæ£€æµ‹åˆ°è¡¨æƒ…æ•°æ®</div>'}
            </div>
          </div>
        `;
      }
      
      formatEmotion(emotion) {
        if (emotion.error) {
          return `<span style="color: red;">${this.escapeHtml(emotion.error)}</span>`;
        }
        return `<code>${this.escapeHtml(JSON.stringify(emotion, null, 2))}</code>`;
      }
      
      downloadVideo() {
        if (!this.recordedBlob) {
          alert('æ²¡æœ‰å½•åˆ¶çš„è§†é¢‘');
          return;
        }
        
        const url = URL.createObjectURL(this.recordedBlob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `recorded_video_${timestamp}.webm`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      updateStatus(message, type = '') {
        this.status.textContent = message;
        this.status.className = `status ${type}`;
      }
      
      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // æ¸…ç†èµ„æº
      destroy() {
        this.stopRecordingTimer();
        if (this.stream) {
          this.stream.getTracks().forEach(track => track.stop());
        }
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
          this.mediaRecorder.stop();
        }
      }
    }
    
    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    let recorder;
    window.addEventListener('load', () => {
      recorder = new VideoRecorder();
    });
    
    // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
    window.addEventListener('beforeunload', () => {
      if (recorder) {
        recorder.destroy();
      }
    });
  </script>
</body>
</html>
