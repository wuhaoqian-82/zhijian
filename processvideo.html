<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‘„åƒå¤´å½•åˆ¶è§†é¢‘åˆ†æ</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background: white;
      border-radius: 10px;
      padding: 30px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h2 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
    }
    .video-container {
      text-align: center;
      margin: 20px 0;
      position: relative;
    }
    video {
      max-width: 100%;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: #000;
    }
    .video-info {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    .controls {
      margin: 20px 0;
      text-align: center;
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    button {
      margin: 5px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 120px;
    }
    .start-btn { 
      background-color: #4CAF50; 
      color: white; 
    }
    .start-btn:hover { 
      background-color: #45a049; 
    }
    .stop-btn { 
      background-color: #f44336; 
      color: white; 
    }
    .stop-btn:hover { 
      background-color: #da190b; 
    }
    .analyze-btn { 
      background-color: #2196F3; 
      color: white; 
    }
    .analyze-btn:hover { 
      background-color: #1976D2; 
    }
    .download-btn { 
      background-color: #FF9800; 
      color: white; 
    }
    .download-btn:hover { 
      background-color: #F57C00; 
    }
    button:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      opacity: 0.6;
    }
    .status {
      margin: 15px 0;
      padding: 15px;
      border-radius: 6px;
      text-align: center;
      font-weight: 500;
    }
    .status.recording { 
      background-color: #ffebee; 
      color: #c62828; 
      border-left: 4px solid #f44336;
    }
    .status.ready { 
      background-color: #e8f5e8; 
      color: #2e7d32; 
      border-left: 4px solid #4CAF50;
    }
    .status.processing { 
      background-color: #fff3e0; 
      color: #ef6c00; 
      border-left: 4px solid #FF9800;
    }
    .status.error { 
      background-color: #ffebee; 
      color: #c62828; 
      border-left: 4px solid #f44336;
    }
    #result {
      margin: 20px 0;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background-color: #f9f9f9;
    }
    .emotion-item {
      margin: 8px 0;
      padding: 12px;
      background-color: white;
      border-radius: 6px;
      border-left: 4px solid #2196F3;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .recording-time {
      font-size: 20px;
      font-weight: bold;
      color: #f44336;
      background: #ffebee;
      padding: 10px 20px;
      border-radius: 20px;
      display: inline-block;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background-color: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #2196F3, #21CBF3);
      transition: width 0.3s ease;
    }
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #2196F3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .compatibility-warning {
      background-color: #fff3cd;
      color: #856404;
      padding: 15px;
      border-radius: 6px;
      margin: 15px 0;
      border-left: 4px solid #ffc107;
    }
    .result-section {
      margin: 20px 0;
      padding: 15px;
      border-radius: 6px;
      background: white;
      border: 1px solid #e0e0e0;
    }
    .result-section h4 {
      margin-top: 0;
      color: #333;
      border-bottom: 2px solid #e0e0e0;
      padding-bottom: 10px;
    }
    .asr-text {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #dee2e6;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Courier New', monospace;
      line-height: 1.5;
      min-height: 60px;
    }
    .emotion-timeline {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #dee2e6;
      border-radius: 6px;
    }
    .processing-info {
      background: #e3f2fd;
      padding: 12px;
      border-radius: 6px;
      margin: 10px 0;
      font-size: 14px;
      color: #1565c0;
    }
    .emotion-details {
      font-size: 11px;
      color: #666;
      margin-top: 5px;
      max-height: 80px;
      overflow-y: auto;
      background: #f8f9fa;
      padding: 8px;
      border-radius: 4px;
    }
    .server-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      z-index: 1000;
      font-weight: bold;
    }
    .server-status.online {
      background: #4CAF50;
      color: white;
    }
    .server-status.offline {
      background: #f44336;
      color: white;
    }
    .server-status.checking {
      background: #FF9800;
      color: white;
    }
    .recording-tips {
      background: #e3f2fd;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      font-size: 13px;
      color: #1976d2;
    }
    .error-details {
      background: #ffebee;
      border: 1px solid #f44336;
      border-radius: 6px;
      padding: 15px;
      margin: 15px 0;
    }
    .error-details h4 {
      color: #d32f2f;
      margin-top: 0;
    }
    .error-details pre {
      background: #fff;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 10px 0;
    }
    .suggestions {
      background: #f3e5f5;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
    }
    .suggestions ul {
      margin: 5px 0;
      padding-left: 20px;
    }
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }
      .controls {
        flex-direction: column;
        align-items: center;
      }
      button {
        width: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ğŸ¥ æ‘„åƒå¤´å½•åˆ¶è§†é¢‘è¡¨æƒ…ä¸è¯­éŸ³åˆ†æ</h2>
    
    <div class="video-container">
      <video id="preview" width="640" height="480" autoplay muted playsinline></video>
      <div class="video-info" id="videoInfo">ç­‰å¾…æ‘„åƒå¤´åˆå§‹åŒ–...</div>
    </div>
    
    <div class="recording-tips" id="recordingTips" style="display: none;">
      ğŸ’¡ å½•åˆ¶æç¤º: è¯·ç¡®ä¿å…‰çº¿å……è¶³ï¼Œè¯´è¯æ¸…æ™°ï¼Œé¿å…èƒŒæ™¯å™ªéŸ³ã€‚å»ºè®®å½•åˆ¶10-30ç§’çš„è§†é¢‘ä»¥è·å¾—æœ€ä½³åˆ†ææ•ˆæœã€‚
    </div>
    
    <div class="controls">
      <button id="startBtn" class="start-btn">ğŸ¬ å¼€å§‹å½•åˆ¶</button>
      <button id="stopBtn" class="stop-btn" disabled>â¹ï¸ åœæ­¢å½•åˆ¶</button>
      <button id="analyzeBtn" class="analyze-btn" disabled>ğŸ” åˆ†æè§†é¢‘</button>
      <button id="downloadBtn" class="download-btn" disabled>â¬‡ï¸ ä¸‹è½½å½•åˆ¶è§†é¢‘</button>
    </div>
    
    <div id="status" class="status">æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...</div>
    <div id="recordingTime" class="recording-time" style="display: none;"></div>
    <div id="progressContainer" style="display: none;">
      <div class="progress-bar">
        <div class="progress-bar-fill" id="progressBar"></div>
      </div>
      <div id="progressText" class="processing-info"></div>
    </div>
    
    <div id="result"></div>
  </div>

  <div id="serverStatus" class="server-status checking">æœåŠ¡å™¨: æ£€æµ‹ä¸­...</div>

  <script>
    class VideoRecorder {
      constructor() {
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.stream = null;
        this.recordingStartTime = null;
        this.recordingTimer = null;
        this.supportedMimeTypes = [];
        this.selectedMimeType = null;
        this.serverOnline = false;
        this.recordingQuality = 'high';
        
        // DOM å…ƒç´ 
        this.preview = document.getElementById('preview');
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.analyzeBtn = document.getElementById('analyzeBtn');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.status = document.getElementById('status');
        this.recordingTime = document.getElementById('recordingTime');
        this.result = document.getElementById('result');
        this.videoInfo = document.getElementById('videoInfo');
        this.progressContainer = document.getElementById('progressContainer');
        this.progressBar = document.getElementById('progressBar');
        this.progressText = document.getElementById('progressText');
        this.serverStatus = document.getElementById('serverStatus');
        this.recordingTips = document.getElementById('recordingTips');
        
        // é…ç½®
        this.serverUrl = this.detectServerUrl();
        
        this.init();
      }
      
      detectServerUrl() {
        // å°è¯•æ£€æµ‹æœåŠ¡å™¨URL
        const possibleUrls = [
          'http://localhost:3100',
          'http://127.0.0.1:3100',
          'http://localhost:3000',
          'http://127.0.0.1:3000'
        ];
        return possibleUrls[0];
      }
      
      async checkBrowserCompatibility() {
        const issues = [];
        
        if (!navigator.mediaDevices) {
          issues.push('ä¸æ”¯æŒåª’ä½“è®¾å¤‡API');
        }
        
        if (!navigator.mediaDevices.getUserMedia) {
          issues.push('ä¸æ”¯æŒgetUserMedia API');
        }
        
        if (!window.MediaRecorder) {
          issues.push('ä¸æ”¯æŒMediaRecorder API');
        }
        
        if (!window.fetch) {
          issues.push('ä¸æ”¯æŒFetch API');
        }
        
        // æ£€æŸ¥æ”¯æŒçš„è§†é¢‘æ ¼å¼
        if (window.MediaRecorder) {
          const testTypes = [
            { type: 'video/webm;codecs=vp9,opus', quality: 'high' },
            { type: 'video/webm;codecs=vp8,opus', quality: 'medium' }, 
            { type: 'video/webm', quality: 'medium' },
            { type: 'video/mp4', quality: 'low' }
          ];
          
          for (const { type, quality } of testTypes) {
            if (MediaRecorder.isTypeSupported(type)) {
              this.supportedMimeTypes.push({ type, quality });
            }
          }
          
          if (this.supportedMimeTypes.length === 0) {
            issues.push('ä¸æ”¯æŒä»»ä½•è§†é¢‘å½•åˆ¶æ ¼å¼');
          } else {
            this.selectedMimeType = this.supportedMimeTypes[0].type;
            this.recordingQuality = this.supportedMimeTypes[0].quality;
          }
        }
        
        return issues;
      }
      
      showCompatibilityWarning(issues) {
        const warningDiv = document.createElement('div');
        warningDiv.className = 'compatibility-warning';
        warningDiv.innerHTML = `
          <h4>âš ï¸ æµè§ˆå™¨å…¼å®¹æ€§è­¦å‘Š</h4>
          <p>æ£€æµ‹åˆ°ä»¥ä¸‹é—®é¢˜ï¼š</p>
          <ul>
            ${issues.map(issue => `<li>${this.escapeHtml(issue)}</li>`).join('')}
          </ul>
          <p>å»ºè®®ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„Chromeã€Firefoxæˆ–Edgeæµè§ˆå™¨ã€‚</p>
        `;
        
        document.querySelector('.container').insertBefore(warningDiv, document.querySelector('.video-container'));
      }
      
      async init() {
        try {
          // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
          const compatibilityIssues = await this.checkBrowserCompatibility();
          if (compatibilityIssues.length > 0) {
            this.showCompatibilityWarning(compatibilityIssues);
            this.updateStatus('æµè§ˆå™¨å…¼å®¹æ€§å­˜åœ¨é—®é¢˜ï¼ŒåŠŸèƒ½å¯èƒ½å—é™', 'error');
            return;
          }
          
          // è¯·æ±‚æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™
          this.updateStatus('æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™...', 'processing');
          
          const constraints = {
            video: {
              width: { ideal: 1280, max: 1920 },
              height: { ideal: 720, max: 1080 },
              frameRate: { ideal: 30, max: 60 }
            },
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: { ideal: 44100, min: 16000 }
            }
          };
          
          this.stream = await navigator.mediaDevices.getUserMedia(constraints);
          this.preview.srcObject = this.stream;
          
          // è·å–å®é™…çš„è§†é¢‘æµä¿¡æ¯
          const videoTrack = this.stream.getVideoTracks()[0];
          const audioTrack = this.stream.getAudioTracks()[0];
          
          if (videoTrack) {
            const settings = videoTrack.getSettings();
            this.videoInfo.innerHTML = `
              ğŸ“¹ è§†é¢‘: ${settings.width || 'æœªçŸ¥'}Ã—${settings.height || 'æœªçŸ¥'} @ ${settings.frameRate || 'æœªçŸ¥'}fps
              ${audioTrack ? `<br>ğŸ¤ éŸ³é¢‘: ${audioTrack.getSettings().sampleRate || 'æœªçŸ¥'}Hz` : ''}
              <br>ğŸ“Š å½•åˆ¶æ ¼å¼: ${this.selectedMimeType || 'æœªçŸ¥'} (${this.recordingQuality}è´¨é‡)
            `;
          }
          
          this.setupEventListeners();
          this.updateStatus('æ‘„åƒå¤´å·²å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»å¼€å§‹å½•åˆ¶', 'ready');
          this.recordingTips.style.display = 'block';
          
          // æµ‹è¯•æœåŠ¡å™¨è¿æ¥
          this.testServerConnection();
          
        } catch (error) {
          console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
          let errorMessage = 'æ‘„åƒå¤´è®¿é—®å¤±è´¥: ';
          
          if (error.name === 'NotAllowedError') {
            errorMessage += 'ç”¨æˆ·æ‹’ç»äº†æ‘„åƒå¤´æƒé™ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸æ‘„åƒå¤´è®¿é—®';
          } else if (error.name === 'NotFoundError') {
            errorMessage += 'æœªæ‰¾åˆ°æ‘„åƒå¤´è®¾å¤‡ï¼Œè¯·ç¡®è®¤æ‘„åƒå¤´å·²è¿æ¥';
          } else if (error.name === 'NotReadableError') {
            errorMessage += 'æ‘„åƒå¤´è¢«å…¶ä»–åº”ç”¨å ç”¨ï¼Œè¯·å…³é—­å…¶ä»–ä½¿ç”¨æ‘„åƒå¤´çš„åº”ç”¨';
          } else if (error.name === 'OverconstrainedError') {
            errorMessage += 'æ‘„åƒå¤´ä¸æ”¯æŒæ‰€è¯·æ±‚çš„é…ç½®ï¼Œå°è¯•é™ä½åˆ†è¾¨ç‡';
          } else {
            errorMessage += error.message;
          }
          
          this.updateStatus(errorMessage, 'error');
        }
      }
      
      async testServerConnection() {
        try {
          this.serverStatus.textContent = 'æœåŠ¡å™¨: æ£€æµ‹ä¸­...';
          this.serverStatus.className = 'server-status checking';
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          
          const response = await fetch(`${this.serverUrl}/health`, {
            method: 'GET',
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (response.ok) {
            const data = await response.json();
            this.serverOnline = true;
            this.serverStatus.textContent = 'ğŸŸ¢ æœåŠ¡å™¨åœ¨çº¿';
            this.serverStatus.className = 'server-status online';
            console.log('æœåŠ¡å™¨è¿æ¥æ­£å¸¸:', data);
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          this.serverOnline = false;
          this.serverStatus.textContent = 'ğŸ”´ æœåŠ¡å™¨ç¦»çº¿';
          this.serverStatus.className = 'server-status offline';
          console.warn('æœåŠ¡å™¨è¿æ¥å¤±è´¥:', error.message);
        }
      }
      
      setupEventListeners() {
        this.startBtn.addEventListener('click', () => this.startRecording());
        this.stopBtn.addEventListener('click', () => this.stopRecording());
        this.analyzeBtn.addEventListener('click', () => this.analyzeVideo());
        this.downloadBtn.addEventListener('click', () => this.downloadVideo());
        
        // ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–
        document.addEventListener('visibilitychange', () => {
          if (document.hidden && this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            console.warn('é¡µé¢éšè—æ—¶å½•åˆ¶å¯èƒ½å—å½±å“');
          }
        });
        
        // å®šæœŸæ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
        setInterval(() => {
          this.testServerConnection();
        }, 30000);
      }
      
      async startRecording() {
        try {
          this.recordedChunks = [];
          
          if (!this.selectedMimeType) {
            throw new Error('æ— å¯ç”¨çš„å½•åˆ¶æ ¼å¼');
          }
          
          // ä¼˜åŒ–å½•åˆ¶å‚æ•°
          const options = {
            mimeType: this.selectedMimeType
          };
          
          // æ ¹æ®æ ¼å¼è°ƒæ•´æ¯”ç‰¹ç‡
          if (this.selectedMimeType.includes('vp9')) {
            options.videoBitsPerSecond = 1500000; // VP9æ›´é«˜æ•ˆ
            options.audioBitsPerSecond = 128000;
          } else if (this.selectedMimeType.includes('vp8')) {
            options.videoBitsPerSecond = 2000000;
            options.audioBitsPerSecond = 128000;
          } else if (this.selectedMimeType.includes('mp4')) {
            options.videoBitsPerSecond = 2500000; // MP4éœ€è¦æ›´é«˜æ¯”ç‰¹ç‡
            options.audioBitsPerSecond = 128000;
          } else {
            options.videoBitsPerSecond = 2000000;
            options.audioBitsPerSecond = 128000;
          }
          
          this.mediaRecorder = new MediaRecorder(this.stream, options);
          
          this.mediaRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
              this.recordedChunks.push(event.data);
              console.log(`å½•åˆ¶æ•°æ®å—: ${event.data.size} bytes, æ€»å—æ•°: ${this.recordedChunks.length}`);
            }
          };
          
          this.mediaRecorder.onstop = () => {
            this.onRecordingComplete();
          };
          
          this.mediaRecorder.onerror = (event) => {
            console.error('å½•åˆ¶é”™è¯¯:', event.error);
            this.updateStatus('å½•åˆ¶å‡ºç°é”™è¯¯: ' + event.error.message, 'error');
            this.resetRecordingState();
          };
          
          this.mediaRecorder.start(250); // æ›´é¢‘ç¹æ”¶é›†æ•°æ®ï¼Œæé«˜ç¨³å®šæ€§
          
          this.recordingStartTime = Date.now();
          this.startRecordingTimer();
          
          this.startBtn.disabled = true;
          this.stopBtn.disabled = false;
          this.analyzeBtn.disabled = true;
          this.downloadBtn.disabled = true;
          
          this.updateStatus('æ­£åœ¨å½•åˆ¶ä¸­... ğŸ“¹', 'recording');
          this.recordingTips.style.display = 'none';
          
        } catch (error) {
          console.error('å¼€å§‹å½•åˆ¶å¤±è´¥:', error);
          this.updateStatus('å½•åˆ¶å¤±è´¥: ' + error.message, 'error');
          this.resetRecordingState();
        }
      }
      
      stopRecording() {
        try {
          if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
          }
          
          this.stopRecordingTimer();
          this.resetRecordingState();
          this.updateStatus('å½•åˆ¶å®Œæˆï¼Œæ­£åœ¨å¤„ç†æ•°æ®...', 'processing');
          
        } catch (error) {
          console.error('åœæ­¢å½•åˆ¶å¤±è´¥:', error);
          this.updateStatus('åœæ­¢å½•åˆ¶å¤±è´¥: ' + error.message, 'error');
          this.resetRecordingState();
        }
      }
      
      resetRecordingState() {
        this.startBtn.disabled = false;
        this.stopBtn.disabled = true;
        this.recordingTips.style.display = 'block';
      }
      
      startRecordingTimer() {
        this.recordingTime.style.display = 'block';
        this.recordingTimer = setInterval(() => {
          const elapsed = Date.now() - this.recordingStartTime;
          const seconds = Math.floor(elapsed / 1000);
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;
          this.recordingTime.textContent = 
            `â±ï¸ å½•åˆ¶æ—¶é—´: ${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
      }
      
      stopRecordingTimer() {
        if (this.recordingTimer) {
          clearInterval(this.recordingTimer);
          this.recordingTimer = null;
        }
        this.recordingTime.style.display = 'none';
      }
      
      onRecordingComplete() {
        try {
          console.log('å¼€å§‹å¤„ç†å½•åˆ¶æ•°æ®, æ•°æ®å—æ•°é‡:', this.recordedChunks.length);
          
          if (this.recordedChunks.length === 0) {
            throw new Error('æ²¡æœ‰å½•åˆ¶åˆ°ä»»ä½•æ•°æ®');
          }
          
          // éªŒè¯æ¯ä¸ªæ•°æ®å—
          const validChunks = this.recordedChunks.filter(chunk => chunk.size > 0);
          if (validChunks.length === 0) {
            throw new Error('æ‰€æœ‰å½•åˆ¶çš„æ•°æ®å—éƒ½æ˜¯ç©ºçš„');
          }
          
          console.log(`æœ‰æ•ˆæ•°æ®å—: ${validChunks.length}/${this.recordedChunks.length}`);
          
          const blob = new Blob(validChunks, { 
            type: this.selectedMimeType || 'video/webm'
          });
          
          if (blob.size === 0) {
            throw new Error('ç”Ÿæˆçš„è§†é¢‘æ–‡ä»¶ä¸ºç©º');
          }
          
          this.recordedBlob = blob;
          
          this.analyzeBtn.disabled = false;
          this.downloadBtn.disabled = false;
          
          // æ˜¾ç¤ºå½•åˆ¶çš„è§†é¢‘ä¿¡æ¯
          const sizeInMB = (blob.size / (1024 * 1024)).toFixed(2);
          const duration = this.recordingStartTime ? 
            Math.round((Date.now() - this.recordingStartTime) / 1000) : 0;
            
          this.updateStatus(
            `å½•åˆ¶å®Œæˆ! æ–‡ä»¶å¤§å°: ${sizeInMB} MB, æ—¶é•¿: ${duration}ç§’`, 
            'ready'
          );
          
          console.log('å½•åˆ¶å®Œæˆ:', {
            size: blob.size,
            sizeMB: sizeInMB,
            type: blob.type,
            chunks: validChunks.length,
            duration: duration
          });
          
        } catch (error) {
          console.error('å½•åˆ¶å®Œæˆå¤„ç†å¤±è´¥:', error);
          this.updateStatus('å½•åˆ¶æ•°æ®å¤„ç†å¤±è´¥: ' + error.message, 'error');
        }
      }
      
      async analyzeVideo() {
        if (!this.recordedBlob) {
          this.updateStatus('æ²¡æœ‰å½•åˆ¶çš„è§†é¢‘æ•°æ®', 'error');
          return;
        }
        
        if (!this.serverOnline) {
          this.updateStatus('æœåŠ¡å™¨ç¦»çº¿ï¼Œæ— æ³•è¿›è¡Œåˆ†æã€‚è¯·æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€ã€‚', 'error');
          return;
        }
        
        this.updateStatus('æ­£åœ¨åˆ†æè§†é¢‘ï¼Œè¯·ç¨å€™...', 'processing');
        this.analyzeBtn.disabled = true;
        this.showProgress(0, 'å‡†å¤‡å‘é€è§†é¢‘æ•°æ®...');
        
        try {
          // å°†Blobè½¬æ¢ä¸ºBase64
          this.showProgress(10, 'æ­£åœ¨ç¼–ç è§†é¢‘æ•°æ®...');
          const base64Data = await this.blobToBase64(this.recordedBlob);
          
          // éªŒè¯base64æ•°æ®
          if (!base64Data || base64Data.length === 0) {
            throw new Error('è§†é¢‘æ•°æ®ç¼–ç å¤±è´¥');
          }
          
          this.showProgress(20, 'æ­£åœ¨å‘é€åˆ°æœåŠ¡å™¨...');
          
          const requestData = {
            videoData: base64Data,
            filename: `recorded_${Date.now()}.webm`
          };
          
          console.log('å‘é€åˆ†æè¯·æ±‚:', {
            originalSize: this.recordedBlob.size,
            base64Size: base64Data.length,
            filename: requestData.filename
          });
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 120000); // 2åˆ†é’Ÿè¶…æ—¶
          
          const response = await fetch(`${this.serverUrl}/api/video/analyze-base64`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData),
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          this.showProgress(60, 'æœåŠ¡å™¨æ­£åœ¨å¤„ç†...');
          
          const data = await response.json();
          
          if (!response.ok) {
            throw new Error(`æœåŠ¡å™¨é”™è¯¯ (${response.status}): ${data.error || data.message || 'æœªçŸ¥é”™è¯¯'}`);
          }
          
          if (data.success) {
            this.showProgress(100, 'åˆ†æå®Œæˆ!');
            this.displayResults(data);
            this.updateStatus('è§†é¢‘åˆ†æå®Œæˆ!', 'ready');
          } else {
            throw new Error(data.error || 'åˆ†æå¤±è´¥');
          }
          
        } catch (error) {
          console.error('åˆ†æå¤±è´¥:', error);
          this.displayError(error);
        } finally {
          this.analyzeBtn.disabled = false;
          this.hideProgress();
        }
      }
      
      displayError(error) {
        let errorMessage = error.message;
        let suggestions = [];
        
        if (error.name === 'AbortError') {
          errorMessage = 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·å°è¯•å½•åˆ¶è¾ƒçŸ­çš„è§†é¢‘';
          suggestions = [
            'å½•åˆ¶10-30ç§’çš„çŸ­è§†é¢‘',
            'æ£€æŸ¥ç½‘ç»œè¿æ¥ç¨³å®šæ€§',
            'é‡å¯æœåŠ¡å™¨åé‡è¯•'
          ];
        } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
          errorMessage = `æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ (${this.serverUrl})`;
          suggestions = [
            'ç¡®è®¤æœåŠ¡å™¨å·²å¯åŠ¨å¹¶è¿è¡Œåœ¨ç«¯å£3100',
            'æ£€æŸ¥é˜²ç«å¢™è®¾ç½®',
            'å°è¯•åˆ·æ–°é¡µé¢',
            'æ£€æŸ¥æœåŠ¡å™¨æ§åˆ¶å°æ˜¯å¦æœ‰é”™è¯¯ä¿¡æ¯'
          ];
        } else if (error.message.includes('413') || error.message.includes('FILE_TOO_LARGE')) {
          errorMessage = 'è§†é¢‘æ–‡ä»¶å¤ªå¤§ï¼ŒæœåŠ¡å™¨æ— æ³•å¤„ç†';
          suggestions = [
            'å½•åˆ¶è¾ƒçŸ­çš„è§†é¢‘ï¼ˆå»ºè®®10-30ç§’ï¼‰',
            'é™ä½å½•åˆ¶è´¨é‡',
            'æ£€æŸ¥æœåŠ¡å™¨é…ç½®çš„æ–‡ä»¶å¤§å°é™åˆ¶'
          ];
        } else if (error.message.includes('400') || error.message.includes('INVALID_VIDEO')) {
          errorMessage = 'è§†é¢‘æ•°æ®æ ¼å¼é”™è¯¯æˆ–æŸå';
          suggestions = [
            'é‡æ–°å½•åˆ¶è§†é¢‘',
            'å°è¯•ä½¿ç”¨ä¸åŒçš„æµè§ˆå™¨',
            'æ£€æŸ¥æ‘„åƒå¤´å’Œéº¦å…‹é£æ˜¯å¦æ­£å¸¸å·¥ä½œ'
          ];
        } else if (error.message.includes('500') || error.message.includes('ffmpeg')) {
          errorMessage = 'æœåŠ¡å™¨å¤„ç†è§†é¢‘æ—¶å‘ç”Ÿé”™è¯¯';
          suggestions = [
            'æ£€æŸ¥æœåŠ¡å™¨æ§åˆ¶å°çš„è¯¦ç»†é”™è¯¯ä¿¡æ¯',
            'ç¡®è®¤ffmpegæ­£ç¡®å®‰è£…',
            'é‡å¯æœåŠ¡å™¨',
            'å°è¯•å½•åˆ¶ä¸åŒæ ¼å¼çš„è§†é¢‘'
          ];
        }
        
        this.result.innerHTML = `
          <div class="error-details">
            <h4>âŒ åˆ†æå¤±è´¥</h4>
            <pre>${this.escapeHtml(errorMessage)}</pre>
            
            ${suggestions.length > 0 ? `
              <div class="suggestions">
                <strong>ğŸ’¡ å»ºè®®è§£å†³æ–¹æ¡ˆï¼š</strong>
                <ul>
                  ${suggestions.map(suggestion => `<li>${this.escapeHtml(suggestion)}</li>`).join('')}
                </ul>
              </div>
            ` : ''}
            
            <div style="margin-top: 15px; font-size: 12px; color: #666;">
              <strong>æŠ€æœ¯ä¿¡æ¯ï¼š</strong><br>
              æœåŠ¡å™¨åœ°å€: ${this.serverUrl}<br>
              å½•åˆ¶æ ¼å¼: ${this.selectedMimeType}<br>
              è§†é¢‘å¤§å°: ${this.recordedBlob ? (this.recordedBlob.size / 1024 / 1024).toFixed(2) + ' MB' : 'æœªçŸ¥'}<br>
              æ—¶é—´æˆ³: ${new Date().toISOString()}
            </div>
          </div>
        `;
        
        this.updateStatus('åˆ†æå¤±è´¥', 'error');
      }
      
      showProgress(percent, message) {
        this.progressContainer.style.display = 'block';
        this.progressBar.style.width = percent + '%';
        this.progressText.innerHTML = `<div class="loading-spinner"></div>${message} (${percent}%)`;
      }
      
      hideProgress() {
        this.progressContainer.style.display = 'none';
      }
      
      blobToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const result = reader.result;
              if (!result) {
                reject(new Error('æ–‡ä»¶è¯»å–ç»“æœä¸ºç©º'));
                return;
              }
              resolve(result);
            } catch (error) {
              reject(new Error('æ–‡ä»¶è¯»å–ç»“æœå¤„ç†å¤±è´¥: ' + error.message));
            }
          };
          reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥: ' + (reader.error?.message || 'æœªçŸ¥é”™è¯¯')));
          reader.readAsDataURL(blob);
        });
      }
      
      displayResults(data) {
        const { 
          emotionTimeline, 
          asrText, 
          asrError,
          processedFrames, 
          processingTimeMs,
          videoInfo 
        } = data;
        
        console.log('æ”¶åˆ°åˆ†æç»“æœ:', data);
        
        let emotionHtml = '';
        if (emotionTimeline && emotionTimeline.length > 0) {
          emotionHtml = emotionTimeline.map((item, index) => 
            `<div class="emotion-item">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <strong>ğŸ–¼ï¸ ç¬¬ ${index + 1} å¸§ (${this.escapeHtml(item.frame || 'unknown')})</strong>
                <span style="font-size: 12px; color: #666;">æ—¶é—´: ${item.timestamp || index}s</span>
              </div>
              <div class="emotion-details">
                ${this.formatEmotion(item.emotion)}
              </div>
            </div>`
          ).join('');
        } else {
          emotionHtml = '<div style="text-align: center; color: #666; padding: 20px;">æœªæ£€æµ‹åˆ°è¡¨æƒ…æ•°æ®</div>';
        }
        
        // ASRç»“æœå¤„ç†
        let asrHtml = '';
        if (asrError) {
          asrHtml = `<div style="color: #d32f2f; padding: 10px; background: #ffebee; border-radius: 4px;">
            <strong>âŒ è¯­éŸ³è¯†åˆ«å¤±è´¥:</strong> ${this.escapeHtml(asrError.message)}<br>
            <small>é”™è¯¯ä»£ç : ${asrError.code || 'æœªçŸ¥'}</small>
          </div>`;
        } else if (asrText && asrText.trim()) {
          asrHtml = `<div class="asr-text">${this.escapeHtml(asrText)}</div>`;
        } else {
          asrHtml = `<div style="color: #666; font-style: italic; text-align: center; padding: 20px;">
            æœªè¯†åˆ«åˆ°è¯­éŸ³å†…å®¹ï¼ˆå¯èƒ½æ˜¯é™éŸ³ã€éŸ³è´¨é—®é¢˜æˆ–è§†é¢‘ä¸­æ— éŸ³é¢‘ï¼‰
          </div>`;
        }
        
        // å¤„ç†ä¿¡æ¯
        const processingInfo = `
          <div class="processing-info">
            ğŸ“Š å¤„ç†ç»Ÿè®¡: å…±å¤„ç† ${processedFrames || 0} å¸§ï¼Œè€—æ—¶ ${processingTimeMs || 0}ms
            ${videoInfo ? `<br>ğŸ“ è§†é¢‘ä¿¡æ¯: ${videoInfo.sizeMB}MB, æ—¶é•¿: ${videoInfo.duration?.toFixed(1) || 'æœªçŸ¥'}ç§’` : ''}
            ${videoInfo ? `<br>ğŸ¥ ç¼–ç æ ¼å¼: è§†é¢‘${videoInfo.videoCodec || 'æœªçŸ¥'}, éŸ³é¢‘${videoInfo.audioCodec || 'æœªçŸ¥'}` : ''}
          </div>
        `;
        
        this.result.innerHTML = `
          <h3>ğŸ“ˆ åˆ†æç»“æœ</h3>
          ${processingInfo}
          
          <div class="result-section">
            <h4>ğŸ¤ è¯­éŸ³è¯†åˆ«ç»“æœ</h4>
            ${asrHtml}
          </div>
          
          <div class="result-section">
            <h4>ğŸ˜Š è¡¨æƒ…åˆ†ææ—¶é—´çº¿</h4>
            <div class="emotion-timeline">
              ${emotionHtml}
            </div>
          </div>
        `;
      }
      
      formatEmotion(emotion) {
        if (!emotion) {
          return '<span style="color: #666;">æ— æ•°æ®</span>';
        }
        
        if (emotion.error) {
          return `<span style="color: red;">âŒ ${this.escapeHtml(emotion.error)}</span>`;
        }
        
        try {
          // æ ¼å¼åŒ–è¡¨æƒ…åˆ†æç»“æœ
          const formatted = JSON.stringify(emotion, null, 2);
          return `<pre style="margin: 0; font-size: 10px; white-space: pre-wrap;">${this.escapeHtml(formatted)}</pre>`;
        } catch (e) {
          return `<span style="color: #666;">æ•°æ®æ ¼å¼é”™è¯¯</span>`;
        }
      }
      
      downloadVideo() {
        if (!this.recordedBlob) {
          this.updateStatus('æ²¡æœ‰å½•åˆ¶çš„è§†é¢‘æ•°æ®', 'error');
          return;
        }
        
        try {
          const url = URL.createObjectURL(this.recordedBlob);
          const a = document.createElement('a');
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
          a.href = url;
          a.download = `recorded_video_${timestamp}.webm`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          this.updateStatus('è§†é¢‘ä¸‹è½½å®Œæˆ', 'ready');
        } catch (error) {
          console.error('ä¸‹è½½å¤±è´¥:', error);
          this.updateStatus('ä¸‹è½½å¤±è´¥: ' + error.message, 'error');
        }
      }
      
      updateStatus(message, type = '') {
        this.status.textContent = message;
        this.status.className = `status ${type}`;
      }
      
      escapeHtml(text) {
        if (typeof text !== 'string') {
          text = String(text);
        }
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // æ¸…ç†èµ„æº
      destroy() {
        this.stopRecordingTimer();
        if (this.stream) {
          this.stream.getTracks().forEach(track => track.stop());
        }
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
          this.mediaRecorder.stop();
        }
      }
    }
    
    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    let recorder;
    window.addEventListener('DOMContentLoaded', () => {
      try {
        recorder = new VideoRecorder();
      } catch (error) {
        console.error('åˆå§‹åŒ–å¤±è´¥:', error);
        document.getElementById('status').textContent = 'åˆå§‹åŒ–å¤±è´¥: ' + error.message;
        document.getElementById('status').className = 'status error';
      }
    });
    
    // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
    window.addEventListener('beforeunload', () => {
      if (recorder) {
        recorder.destroy();
      }
    });
    
    // å…¨å±€é”™è¯¯å¤„ç†
    window.addEventListener('error', (event) => {
      console.error('é¡µé¢é”™è¯¯:', event.error);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('æœªå¤„ç†çš„Promiseé”™è¯¯:', event.reason);
    });
  </script>
</body>
</html>
